
程序将内存视为一个非常大的数组，数组元素由一个个字节组成，每个字节由唯一的数字（地址address）表示，所有地址的集合称为**虚拟地址空间**

**字节（byte）** 是信息存储的基本单位，由八个**位（bit）** 组成

#### 将2的n次方快速转换为十六进制数

2的n次方的数以二进制写出就是1后面跟n个零，四个二进制的零可以合并为一个十六进制的零，因此，可以将n分解为i+4j

|     |     |     |     |     |
| --- | --- | --- | --- | --- |
| i   | 0   | 1   | 2   | 3   |
| hex | 1   | 2   | 4   | 8   |
例如2的11次方，11=3+2*4，所以等于0x800.

#### 字长

字长决定了虚拟地址空间的最大可以达到多少，对于一个字长为w位的机器，虚拟地址的范围是0~2的w次方减1.

下表展示了不同数据类型在32位和64位机器上所占字节数大小

| signed  | unsigned       | 32-bit | 64-bit |
| ------- | -------------- | ------ | ------ |
| char    | unsigned char  | 1      | 1      |
| short   | unsigned short | 2      | 2      |
| int     | unsigned       | 4      | 4      |
| long    | unsigned long  | 4      | 8      |
| int32_t | uint32_t       | 4      | 4      |
| int64_t | uint64_t       | 8      | 8      |
| char *  |                | 4      | 8      |
| float   |                | 4      | 4      |
| double  |                | 8      | 8      |
大端法：最高有效字节存储在最前面（IBM、SUM)
小端法：最高有效字节储存在最后面（intel)

```c
#include<stdio.h>

typedef unsigned char *byte_pointer;
  
void show_bytes(byte_pointer start, int len){
    for(int i=0; i<len; i++)
        printf("%.2x ", start[i]);
    printf("\n");
}

int main(){
    int i;
    scanf("%d", &i);
    show_bytes((byte_pointer) &i, sizeof(i));
    //强制类型转换告诉编译器，程序应把该指针视作指向一个字节的序列，而不是该对象原始的数据类型
}
```

此程序可打印出程序对象的字节表示

### 运算

与 或 非 略

异或：相同为0，不同为1

#### 通过位运算可以得到特定的位序列

& 0xFF 得到最低有效字节

#### 移位运算

左移：丢弃左边，右边补零
逻辑右移：丢弃右边，左边补零
算数右移：最高位为0补0，为1补1

c语言没有明确规定，但几乎所有编译器以及机器的组合都是将有符号数**算数右移**, 无符号数逻辑右移