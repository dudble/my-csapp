
### 对无符号数的编码

假设有一个整数的数据类型有w位，用向量x表示。
$$
\vec{x} = [x_{w-1}, x_{w-2}, ..., x_0]
$$
 用函数B2U(binary to unsigned)映射到无符号数
 $$
 B2U_w(\vec{x}) = x_{w-1}2^{w-1}+x_{w-2}2^{w-2}+...+x_02^0=\sum_{i=0}^{w-1}x_i2^i
 $$
### 对有符号数的编码

同上，用函数B2T映射到有符号数

$$
 B2T_w(\vec{x}) = -x_{w-1}2^{w-1}+x_{w-2}2^{w-2}+...+x_02^0=\sum_{i=0}^{w-2}x_i2^i-x_{w-1}2^{w-1}
$$
 对于大多数C语言的实现，有符号数和无符号数的转换规则是**位模式不变，解释这些位的方式改变**，对上述两个函数做差，得到的结果便是两数数值的差异，故
$$
 B2U_w=x_{w-1}2^w+B2T_w
$$
#### 将较小数据类型转换为较大数据类型

无符号数直接在空位补0即可，有符号数需要进行符号位扩展，符号位为1补1，为0补零，这样可保证原数据不变，可由数学归纳法证明.

$$
B2T_w([x_{w-1}, x_{w-2}, ..., x_0])\ \ \ (1)
$$

$$
B2T_{w+k}([x_{w-1}, ..., x_{w-1}, x_{w-2}, ..., x_0])\ \ \ (2)
$$

要证明上式相等，只需要证明$B2T_{w+1}==B2T{w}$即可

$$
B2T_{w+1}-B2T_{w}= -x_{w-1}2^{w}+x_{w-1}2^{w-1}+x_{w-1}2^{w-1}=0
$$

#### 将较大数据类型转换为较小数据类型

无符号数直接丢弃高位，可对应于取模运算

有符号数

$$
B2T_k([x_{w-1}, x_{w-2}, ..., x_0])=U2T_{w}(B2U_w([x_{w-1}, x_{w-2}, ..., x_0])\ mod\ 2^k)
$$

先将其视作无符号数解释底层二进制位，用无符号数的截断方式得到最低k位，再将该无符号数转换为有符号数
